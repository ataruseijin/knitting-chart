<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ドット絵 → 編み図変換（右下スタート・行ハイライト修正）</title>
<style>
  /* 全体 */
  body{
    font-family: 'Yu Gothic','ヒラギノ角ゴ Pro','メイリオ',sans-serif;
    background:#fff8f0;
    color:#5a3e1b;
    margin:0;
    padding:20px 10px;
    display:flex;
    flex-direction:column;
    align-items:center;
    box-sizing:border-box;
    min-height:100vh;
  }

  /* controls */
  #controls{ width:100%; max-width:540px; display:flex; flex-wrap:wrap; gap:12px; justify-content:center; margin-bottom:12px; }
  label{ display:flex; flex-direction:column; align-items:center; min-width:86px; user-select:none; }
  input[type=number]{ width:66px; padding:6px 8px; border-radius:6px; border:1px solid #c9a96d; background:#fffef6; text-align:center; }
  input[type=file]{ margin-top:6px; }

  #size-change-alert{ display:none; color:#d75e00; font-weight:bold; text-align:center; width:100%; margin-top:6px; }

  /* pattern */
  #pattern{
    width:100%;
    max-width:100vw;
    overflow:auto;
    margin-bottom:140px; /* カウンター分の余白 */
    border-radius:12px;
    background:#f7e8d0;
    padding:8px;
  }
  table{ border-collapse:separate; border-spacing:4px; width:100%; }
  td{
    width:34px; height:34px; border-radius:10px;
    text-align:center; vertical-align:middle;
    font-weight:700; font-size:18px;
    box-shadow:inset 0 0 8px rgba(0,0,0,0.08);
    cursor:pointer; user-select:none;
    transition: box-shadow .15s, transform .08s, outline .12s, background-color .12s;
  }
  td:active{ transform: translateY(1px); }
  .row-label{ font-weight:700; padding:0 12px; color:#7a5a2a; white-space:nowrap; }

  /* 現在の段を目立たせる（trに付ける） */
tr.current-row td{
background: #ffffff; /* 明るいオレンジ系背景 */
box-shadow: 0 0 12px 6px rgba(255,165,0,0.6); /* 強めのオレンジ光彩 */
color: #ff7b00; /* 濃い文字色でコントラストアップ */
font-weight: 900;
transition: background-color 0.3s ease, box-shadow 0.3s ease;
}

  /* 現在の目（さらに強調） */
  .current-stitch {
    box-shadow: 0 0 18px 6px rgba(215,94,0,0.95);
    outline: 3px solid rgba(255,217,179,0.95);
    outline-offset: -4px;
  }

  /* color palette */
  #colorPalette{ width:100%; max-width:540px; display:flex; gap:12px; overflow-x:auto; padding:8px 0; justify-content:center; margin-bottom:10px; }
  .color-swatch{ width:44px; height:44px; border-radius:12px; box-shadow:inset 0 0 6px rgba(0,0,0,0.12); position:relative; flex-shrink:0; border:3px solid transparent; }
  .color-swatch.selected{ border-color:#d75e00; box-shadow:0 0 8px 3px #d75e00; }
  .color-label{ position:absolute; bottom:-18px; width:100%; text-align:center; font-size:12px; color:#5a3e1b; user-select:none; }
  input[type=color]{ position:absolute; opacity:0; inset:0; width:100%; height:100%; cursor:pointer; border:none; padding:0; margin:0; }

  /* counter fixed bottom */
  .counter{
    position:fixed; left:50%; bottom:10px; transform:translateX(-50%);
    z-index:10000; width:100%; max-width:560px;
    background:rgba(243,222,192,0.98); padding:14px; border-radius:14px;
    box-shadow:0 -8px 28px rgba(183,146,82,0.35); display:flex; gap:12px; flex-direction:column; align-items:center;
  }
  .counter-display{ display:flex; gap:18px; font-weight:700; justify-content:center; flex-wrap:wrap; }
  .counter-buttons{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }

  button{ background:#d9b382; border:none; border-radius:12px; padding:10px 16px; font-weight:700; color:#442d00; cursor:pointer; box-shadow:0 4px 0 #a07a3a; min-width:64px; }
  button:active{ box-shadow:none; transform:translateY(2px); } button:hover{ background:#c3a561; }

  /* voice button */
  #btnVoiceStart{ position:fixed; right:12px; top:12px; z-index:11000; background:#d9b382; border:none; border-radius:10px; padding:10px 14px; font-weight:700; cursor:pointer; box-shadow:0 4px 0 #a07a3a; }

  @media(max-width:480px){
    td{ width:26px; height:26px; font-size:14px; }
    .counter{ padding:12px; max-width:94vw; }
    button{ padding:8px 12px; font-size:14px; min-width:52px; }
    #controls{ flex-direction:column; gap:10px; align-items:stretch; }
  }
</style>
</head>
<body>

<div id="controls">
  <label>幅（横の目数）:
    <input id="inputWidth" type="number" min="4" max="64" value="20" />
  </label>
  <label>高さ（段数）:
    <input id="inputHeight" type="number" min="4" max="64" value="20" />
  </label>
  <label>画像を選択:
    <input id="imageLoader" type="file" accept="image/*" />
  </label>
  <div id="size-change-alert">サイズ変更は、画像を再読み込みすると反映されます</div>
</div>

<div id="colorPalette" aria-label="色パレット編集"></div>
<div id="pattern" aria-label="編み図表示"></div>

<div class="counter" aria-label="編み物カウンター">
  <div class="counter-display">
    <div>段: <span id="rowCount">0</span>段 (<span id="rowType">表</span>)</div>
    <div>目: <span id="stitchCount">0</span>目</div>
  </div>
  <div class="counter-buttons">
    <button id="btnPrevStitch" aria-label="目を戻す">目−</button>
    <button id="btnNextStitch" aria-label="目を進める">目＋</button>
    <button id="btnNextRow" aria-label="次の段">次の段へ</button>
    <button id="btnReset" aria-label="リセット">リセット</button>
  </div>
</div>

<button id="btnVoiceStart" aria-label="音声操作開始">音声操作開始</button>
<canvas id="canvas" style="display:none;"></canvas>

<script>
(() => {
  // DOM
  const imageLoader = document.getElementById('imageLoader');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const patternDiv = document.getElementById('pattern');
  const colorPaletteDiv = document.getElementById('colorPalette');
  const inputWidth = document.getElementById('inputWidth');
  const inputHeight = document.getElementById('inputHeight');
  const rowCountEl = document.getElementById('rowCount');
  const rowTypeEl = document.getElementById('rowType');
  const stitchCountEl = document.getElementById('stitchCount');
  const btnPrevStitch = document.getElementById('btnPrevStitch');
  const btnNextStitch = document.getElementById('btnNextStitch');
  const btnNextRow = document.getElementById('btnNextRow');
  const btnReset = document.getElementById('btnReset');
  const btnVoiceStart = document.getElementById('btnVoiceStart');
  const sizeChangeAlert = document.getElementById('size-change-alert');

  // State
  let totalRows = 0, totalCols = 0;
  let cellMap = []; // data rows: index 0 = bottom row; each row: array of cells left->right
  let currentRow = 1; // 1 = bottom row
  let currentStitchInRow = 1;

  let yarnColors = [
    {hex:'#000000', symbol:'■'},
    {hex:'#ffffff', symbol:'□'},
    {hex:'#ff0000', symbol:'▲'},
    {hex:'#00ff00', symbol:'●'},
    {hex:'#0000ff', symbol:'★'}
  ];

  // util
  function hexToRgb(hex){ const bigint = parseInt(hex.slice(1),16); return [(bigint>>16)&255,(bigint>>8)&255, bigint&255]; }
  function rgbToHex(r,g,b){ return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }
  function colorDistance(a,b){ return (a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2; }

  function extractColorsFromImage(imageData, maxColors=5){
    const data = imageData.data;
    const map = new Map();
    for(let i=0;i<data.length;i+=4){
      const hex = rgbToHex(data[i],data[i+1],data[i+2]);
      map.set(hex, (map.get(hex)||0)+1);
    }
    const sorted = [...map.entries()].sort((a,b)=>b[1]-a[1]).slice(0,maxColors).map(x=>x[0]);
    const colors = sorted.slice();
    for(const c of ['#000000','#ffffff','#ff0000','#00ff00','#0000ff']){
      if(colors.length>=maxColors) break;
      if(!colors.includes(c)) colors.push(c);
    }
    return colors.slice(0,maxColors);
  }

  function findNearestColorIndex(hex){
    const rgb = hexToRgb(hex);
    let min=Infinity, idx=0;
    yarnColors.forEach((c,i)=>{
      const d = colorDistance(rgb, hexToRgb(c.hex));
      if(d<min){ min=d; idx=i; }
    });
    return idx;
  }

  // render: visually top-to-bottom, left-to-right cells
  function renderPattern(){
    if(!totalRows || !totalCols){ patternDiv.innerHTML = '<div style="text-align:center;color:#7a5a2a;padding:18px;">編み図がありません</div>'; return; }
    let html = '<table>';
    // display rows from top (data index totalRows-1) down to bottom (index 0)
    for(let r = totalRows - 1; r >= 0; r--){
      const rowNumber = r + 1; // 1 = bottom
      const isRightToLeft = (rowNumber % 2 === 1); // odd row = right->left knitting
      const arrow = isRightToLeft ? '←' : '→'; // ← means knitting right->left
      // put data-row on TR so we can easily highlight the whole row
      html += `<tr data-row="${r}"><td class="row-label">${rowNumber} (${isRightToLeft ? '表' : '裏'}) ${arrow}</td>`;
      const row = cellMap[r];
      for(let c = 0; c < row.length; c++){
        const cell = row[c];
        const color = yarnColors[cell.colorIndex];
        html += `<td data-col="${c}" style="background:${color.hex}">${color.symbol}</td>`;
      }
      html += '</tr>';
    }
    html += '</table>';
    patternDiv.innerHTML = html;
    updateCounterDisplay(true);
  }

  // compute data column index from currentRow/currentStitchInRow
  function getColumnIndex(){
    const isRightToLeft = (currentRow % 2 === 1);
    return isRightToLeft ? (totalCols - currentStitchInRow) : (currentStitchInRow - 1);
  }

  // highlight current row (TR) and current stitch (TD). autoScroll when requested.
  function updateCounterDisplay(autoScroll = false){
    rowCountEl.textContent = currentRow;
    rowTypeEl.textContent = (currentRow % 2 === 1) ? '表' : '裏';
    stitchCountEl.textContent = currentStitchInRow;

    // remove previous highlights
    patternDiv.querySelectorAll('tr').forEach(tr => tr.classList.remove('current-row'));
    patternDiv.querySelectorAll('td').forEach(td => td.classList.remove('current-stitch'));

    if(!totalCols || !cellMap.length) return;

    const rowIdx = currentRow - 1;
    const colIdx = getColumnIndex();

    // highlight TR
    const tr = patternDiv.querySelector(`tr[data-row="${rowIdx}"]`);
    if(tr) tr.classList.add('current-row');

    // highlight TD within that TR
    const td = tr ? tr.querySelector(`td[data-col="${colIdx}"]`) : null;
    if(td){
      td.classList.add('current-stitch');
      if(autoScroll){
        // first ensure the td is visible inside the pattern container
        // use scrollIntoView on td to bring it to center of pattern container
        td.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
        // then also make sure it's not hidden by the fixed counter at the bottom of the viewport
        setTimeout(()=> {
          const rect = td.getBoundingClientRect();
          const viewportHeight = window.innerHeight;
          const counterHeight = document.querySelector('.counter')?.getBoundingClientRect().height || 0;
          if(rect.bottom > (viewportHeight - counterHeight - 16)){
            window.scrollBy({ top: rect.bottom - (viewportHeight - counterHeight) + 20, behavior: 'smooth' });
          } else if(rect.top < 64){
            window.scrollBy({ top: rect.top - 64, behavior: 'smooth' });
          }
        }, 220);
      }
    }
  }

  // navigation
  function incrementStitch(){
    if(currentStitchInRow < totalCols){
      currentStitchInRow++;
    } else if(currentRow < totalRows){
      currentRow++;
      currentStitchInRow = 1;
    }
    updateCounterDisplay(true);
  }
  function decrementStitch(){
    if(currentStitchInRow > 1){
      currentStitchInRow--;
    } else if(currentRow > 1){
      currentRow--;
      currentStitchInRow = totalCols;
    }
    updateCounterDisplay(true);
  }
  function nextRow(){
    if(currentRow < totalRows){
      currentRow++;
      currentStitchInRow = 1;
      updateCounterDisplay(true);
    }
  }
  function resetCounter(){
    currentRow = 1;
    currentStitchInRow = 1;
    updateCounterDisplay(true);
  }

  // build pattern from image
  function buildPatternFromImage(img, w, h){
    canvas.width = w; canvas.height = h;
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0,0,w,h);
    ctx.drawImage(img,0,0,w,h);
    const imageData = ctx.getImageData(0,0,w,h);
    const extracted = extractColorsFromImage(imageData,5);
    extracted.forEach((hex,i)=>{ if(yarnColors[i]) yarnColors[i].hex = hex; });
    totalCols = w; totalRows = h;
    cellMap = [];
    for(let y = h-1; y >= 0; y--){
      const row = [];
      for(let x = 0; x < w; x++){
        const idx = (y * w + x) * 4;
        const hex = rgbToHex(imageData.data[idx], imageData.data[idx+1], imageData.data[idx+2]);
        const nearest = findNearestColorIndex(hex);
        row.push({ colorIndex: nearest });
      }
      cellMap.push(row);
    }
    sizeChangeAlert.style.display = 'none';
    renderPattern();
    updateColorPaletteUI();
    resetCounter();
    setTimeout(()=> updateCounterDisplay(true), 120);
  }

  // click to toggle color
  function onPatternClick(e){
    const td = e.target.closest('td');
    if(!td || td.classList.contains('row-label')) return;
    const tr = td.parentElement;
    const domRowIndex = Number(tr.dataset.row);
    const col = Number(td.dataset.col);
    if(Number.isInteger(domRowIndex) && Number.isInteger(col) && cellMap[domRowIndex] && cellMap[domRowIndex][col]){
      let idx = cellMap[domRowIndex][col].colorIndex;
      idx = (idx + 1) % yarnColors.length;
      cellMap[domRowIndex][col].colorIndex = idx;
      renderPattern();
    }
  }

  function updateColorPaletteUI(){
    colorPaletteDiv.innerHTML = '';
    yarnColors.forEach((c,i)=>{
      const sw = document.createElement('div'); sw.className='color-swatch'; sw.style.background = c.hex;
      const lbl = document.createElement('div'); lbl.className='color-label'; lbl.textContent = c.symbol;
      const inp = document.createElement('input'); inp.type='color'; inp.value = c.hex;
      inp.addEventListener('input', (ev)=>{ yarnColors[i].hex = ev.target.value; sw.style.background = ev.target.value; renderPattern(); });
      sw.appendChild(lbl); sw.appendChild(inp); colorPaletteDiv.appendChild(sw);
    });
  }

  // events
  imageLoader.addEventListener('change', e => {
    const file = e.target.files && e.target.files[0];
    if(!file) return;
    const img = new Image();
    const reader = new FileReader();
    reader.onload = ev => {
      img.onload = () => {
        const w = Math.max(4, Math.min(64, parseInt(inputWidth.value)||20));
        const h = Math.max(4, Math.min(64, parseInt(inputHeight.value)||20));
        buildPatternFromImage(img, w, h);
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  });

  patternDiv.addEventListener('click', onPatternClick);
  inputWidth.addEventListener('change', ()=> sizeChangeAlert.style.display = 'block');
  inputHeight.addEventListener('change', ()=> sizeChangeAlert.style.display = 'block');

  btnNextStitch.addEventListener('click', ()=> incrementStitch());
  btnPrevStitch.addEventListener('click', ()=> decrementStitch());
  btnNextRow.addEventListener('click', ()=> nextRow());
  btnReset.addEventListener('click', ()=> resetCounter());

  // speech recognition
  let recognition = null, recognizing = false;
  function initRecognition(){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if(!SR) return null;
    const rec = new SR();
    rec.lang = 'ja-JP'; rec.interimResults = false; rec.continuous = true;
    rec.onstart = ()=>{ recognizing = true; btnVoiceStart.textContent = '音声停止'; btnVoiceStart.style.background = '#a05a00'; };
    rec.onend = ()=>{ recognizing = false; btnVoiceStart.textContent = '音声操作開始'; btnVoiceStart.style.background = ''; };
    rec.onerror = e => console.error('Speech error', JSON.stringify(e));
    rec.onresult = ev => {
      for(let i = ev.resultIndex; i < ev.results.length; i++){
        if(ev.results[i].isFinal){
          const text = ev.results[i][0].transcript.trim();
          console.log('音声:', text);
          handleVoiceCommand(text);
        }
      }
    };
    return rec;
  }
  function handleVoiceCommand(text){
    const t = text.replace(/\s+/g,'').toLowerCase();
    if(/次/.test(t)){ nextRow(); speak('次の段へ'); return; }
    if(/プラス/.test(t)){ incrementStitch(); speak('目を一つ進めます'); return; }
    if(/マイナス/.test(t)){ decrementStitch(); speak('目を一つ戻します'); return; }
    if(/リセット/.test(t)){ resetCounter(); speak('リセットしました'); return; }
    if(/ストップ/.test(t)){ if(recognition) recognition.stop(); speak('音声操作を停止します'); return; }
  }
  function speak(text){ if(!('speechSynthesis' in window)) return; const u = new SpeechSynthesisUtterance(text); u.lang='ja-JP'; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u); }

  btnVoiceStart.addEventListener('click', ()=>{
    if(!recognition){ recognition = initRecognition(); if(!recognition){ alert('このブラウザは音声認識に対応していません。Chrome等で試してください'); return; } }
    if(recognizing) recognition.stop(); else recognition.start();
  });

  // init
  updateColorPaletteUI();
  resetCounter();

  // expose for debugging
  window._knitApp = { incrementStitch, decrementStitch, nextRow, resetCounter, renderPattern, cellMap, yarnColors };

})();
</script>
</body>
</html>
